\documentclass{book} 

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{float}
\usepackage{hyperref}
\usepackage{placeins}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{hyperref}

\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{snakes}
\usetikzlibrary{decorations.pathmorphing}

\hypersetup{colorlinks=true,linkcolor=blue, linktocpage}

\title{Online Contests Solutions}
\author{Saman Saadi}
\date{}

\lstdefinestyle{customcpp}{
	belowcaptionskip=1\baselineskip,
	breaklines=true,
	frame=L,
	xleftmargin=\parindent,
	language=C++,
	frame=single,
	showstringspaces=false,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\bfseries\color{green!40!black},
	commentstyle=\itshape\color{purple!40!black},
	identifierstyle=\color{black},
	stringstyle=\color{orange},
	emph={int,char,double,float,unsigned, auto},
	emphstyle={\color{blue}}
}

\lstset{escapechar=@,style=customcpp}

\begin{document}
	\frontmatter
	\maketitle
%	\newpage
	\tableofcontents
	\mainmatter
	\chapter{LeetCode}
	\section{Medium}
	\subsection{\href{https://leetcode.com/problems/longest-substring-without-repeating-characters}{Longest Substring Without Repeating Characters}}
	Find the length of the longest substring without repeating characters. For example in "abcabcbb" the answer is "abc".
	\par We can use mathematical induction. Assume $s[i..j - 1]$ is a valid substring (it doesn't have any repetitive characters). Now we want to add $s[j]$ to it. If $s[j]$ is not in $s[i..j-1]$, then we can easily add $s[j]$ to the list and claim $s[i..j]$ is also valid. Otherwise there is exactly one $i \le k \le j - 1$ that $s[k] = s[j]$.
	\par Because of $s[j]$, we cannot extend $s[i..j - 1]$ anymore, but we may be able to extend $s[k +1..j]$. The running time of the following implementation is $O(n)$:
	\begin{lstlisting}
int lengthOfLongestSubstring(string s) {
  int res = 0;
  unordered_map<char, int> mp;
  for (int i = 0, j = 0; i < s.length() && j < s.length(); ++j)
  {
    auto iter = mp.find(s[j]);
    if (iter != mp.end())
    {
      //Note that after mp.erase, iter will be invalid!
      //So we store the index in k
      int k = iter->second;
      for (; i <= k; ++i)
        mp.erase(s[i]);
    }
    mp[s[j]] = j;
    res = max(res, j - i + 1);
  }
  return res;
}
	\end{lstlisting}
	\subsection{\href{https://leetcode.com/problems/longest-palindromic-substring/}{Longest Palindromic Substring}}
	\label{subsec:longest_palindromic_substr}
	Given a string $s$, return the longest palindromic substring in $s$. For another variation of this problem refer to \ref{subsec:the_palindrome}.
	\par Assume $S[i..j]=s_i s_{i + 1} \dots s_j$. We define $S^\prime[i^\prime .. j^\prime] = s_{i^\prime} s_{i^{\prime} + 1} \dots s_{j^\prime}$ in such a way $(s_j = s_{i^\prime}) \land (s_{j - 1} = s_{i^\prime + 1}) \land \dots \land (s_i = s_{j^\prime})$. Let's Assume string $P$ is a palindromic string and $c$ is an arbitrary character. We can break $P$ into:
	\begin{equation*}
		P[i..j] = \begin{cases}
			S[i..m]S^\prime[m + 1 .. j] & (j - i + 1) \text{ is even} \\
			S[i..m - 1]cS^\prime[m + 1 .. j] & (j - i + 1) \text{ is odd}
		\end{cases}
	\end{equation*}
	It's obvious that $m = \lfloor \frac{i + j}{2} \rfloor$. To solve this problem we need to find the place of m that can be $0 \le m < n$. $n$ is the length of the string. The running time of this algorithm is $O(n^2)$:
	\begin{lstlisting}
string longestPalindrome(string s) {
  int len = 0;
  int index = -1;
  
  const auto findLongest = [&](int l, int r)
  {
    for (; l >= 0 && r < s.length() && s[l] == s[r]; --l, ++r)
    {
      if ((r - l + 1) > len)
      {
        len = r - l + 1;
        index = l;
      }
    }
  };
  
  for (int m = 0; m < s.length(); ++m)
  {
    //Check for S S_r (length is even)
    findLongest(m, m + 1);
    //Check for S c S_r (length is odd)
    findLongest(m, m);
  }
  if (index == -1)
    return "";
  return s.substr(index, len);
}
	\end{lstlisting}
	\subsection{\href{https://leetcode.com/problems/container-with-most-water/}{Container With Most Water}}
	You are given an integer array $hieght$ of length $n$. There are $n$ vertical lines drawn such that the two endpoints of $i^{th}$ line are $(i, 0)$ and $(i, height[i])$. Find two lines that together with the x-axis form a container, such that the container contains the most water. You may not slant the container.
	\par We use mathematical induction. Suppose we know the answer for the number of lines less than $n$. Now we consider $n$ lines. We consider the first and $n^{th}$ lines and call them $l_1$ and $l_n$:
	\begin{enumerate}
		\item $height[1] < height[n]$: We find the best solution for $l_1$. Because for $2 \le k \le n - 1$, the container $l_1$ and $l_k$ cannot have more water than $l_1$ and $l_n$. We can safely remove $l_1$ and use mathematical induction to find the optimal solution. Then we need to compare that solution with $l_1$ and $l_n$ and choose the maximum
		\item $height[1] > height[n]$: We find the best solution for $l_n$, like above we can safely remove $l_n$ and find the best solution and compare it with $l_1$ and $l_n$
		\item $height[1] = height[n]$ We find the best solution for both $l_1$ and $l_n$. We can safely remove both of them and find the optimal solution and compare it with $l_1$ and $l_n$.
	\end{enumerate}
	The running time of this algorithm is $O(n)$.
	\begin{lstlisting}
int maxArea(vector<int>& height) {
  int left = 0, right = height.size() - 1;
  int res = 0;
  while (left < right)
  {
    if (height[left] < height[right])
    {
      res = max(res, (right - left) * height[left]);
      ++left;
    }
    else if (height[left] > height[right])
    {
      res = max(res, (right - left) * height[right]);
      --right;
    }
    else
    {
      res = max (res, (right - left) * height[right]);
      ++left;
      --right;
    }
  }
  return res;
}
	\end{lstlisting}
	\subsection{\href{https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/}{Two Sum II - Input Array Is Sorted}}
	\label{subsec:twosumii}
	Given a sorted array, return two indices $i, j$ such that $numbers[i] + numbers[j] = target \land i < j$. The indices start from $1$.
	\par For similar questions, refer to \ref{subsec:3sum}. For a general solution refer to \ref{subsec:4sum}
	\par We use mathematical induction. We assume we know the solution for all sorted arrays with length less than $n$. Now consider a sorted array with length $n$:
	\begin{enumerate}
		\item $numbers[0] + numbers[n - 1] < target$: Since the array is sorted, $numbers[n - 1]$ is the maximum and $numbers[0]$ is the minimum. So $numbers[0]$ cannot be in the solution. We use mathematical induction to get the answer from $numbers[1..n-1]$
		\item $numbers[0] + numbers[n - 1] > target$: With a similar argument we can say $numbers[n - 1]$ cannot be in the solution. So we use the induction to solve $numbers[0..n - 2]$
		\item $number[0] + numbers[n - 1] == target$: We have the solution.		
	\end{enumerate}
	\begin{lstlisting}
vector<int> twoSum(vector<int>& numbers, int target) {
  
  int left = 0, right = numbers.size() - 1;
  while (left < right)
  {
    const auto sum = numbers[left] + numbers[right];
    if (sum < target)
      ++left;
    else if ( sum > target)
      --right;
    else
      return {left + 1, right + 1};
  }
  throw 1;
}
	\end{lstlisting}
	\subsection{\href{https://leetcode.com/problems/3sum/}{3Sum}}
	\label{subsec:3sum}
	Given an integer array nums, return all triplets $[nums[i], nums[j], nums[k]]$ such that $i \ne j \land i \ne k \land j \ne k$. Notice that the solution set must not contain \textbf{duplicate triplets}.
	\par This is the extension of \ref{subsec:twosumii}. For general solution refer to \ref{subsec:4sum}
	\par The tricky part here is how to avoid duplicates. We assume $nums$ is sorted, then we use mathematical induction. We assume we know how to solve it for less than $n$ sorted numbers. Now we want to solve $n$ sorted numbers. We consider the first element $nums[0]$. Now consider $nums[j]$ such that $j = k + 1$. We define $k$ as $\{nums[0], nums[1], \dots, nums[k]\}$ such that $nums[m] = nums[m + 1]$ for $0 \le m \le k - 1$. We use mathematical induction to find the answers for $nums[j..n - 1]$. 
	\par Note that we cannot use induction for subproblems $nums[m..n - 1]$ for $1 \le m \le k$ because it's possible they have triplets that start with $nums[0]$. As mentioned in problem statement, duplicates are not allowed.
	\par Then we need to find the answers that contain $nums[0]$. For doing that we should find set $S$:
	\begin{equation*}
		S = \{\{p, q\}: 1 \le p < q \le n - 1 \land nums[p] + nums[q] = -nums[0]\}
	\end{equation*}
	Note that $S$ shouldn't have any duplicates. Also it's important that we should find the pairs in $nums[1..n - 1]$ (not in $nums[j..n - 1]$. For example $[0, 0, 0]$ is a valid triplet). This is \href{https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/}{two sum II problem} (refer to \ref{subsec:twosumii}), but we should handle duplicates. There are two solutions to implement two sum:
	\begin{lstlisting}
vector<vector<int>> threeSum(vector<int>& nums) {
  vector<vector<int>> res;
  
  sort(nums.begin(), nums.end()); //O(nlogn)
  unordered_set<int> visited;
  for (int i = 0; i < nums.size() && nums[i] <= 0; ++i)
  {
    // To find subprolem nums[j..n - 1]
    //note that i points to the first repetitive character
    if (i > 0 && nums[i] == nums[i - 1])
      continue;
    visited.clear();
    for (int j = i + 1; j < nums.size(); ++j)
    {
      //make sure j points to the last repetitive character:
      if (j + 1 < nums.size() && nums[j] == nums[j + 1])
      {
        // to handle cases like [0, 0, 0]
        visited.insert(nums[j]);
        continue;
      }
      auto target = -nums[i] - nums[j];
      if (visited.count(target) > 0)
        res.push_back({nums[i], target, nums[j]});
      visited.insert(nums[j]);
    }
  }
  return res;
}
	\end{lstlisting}
	The second solution:
	\begin{lstlisting}
vector<vector<int>> threeSum(vector<int>& nums) {
  vector<vector<int>> res;
  
  sort(nums.begin(), nums.end()); //O(nlogn)        
  for (int i = 0; i + 1 < nums.size() && nums[i] <= 0; ++i)
  {
    // To find subprolem nums[j..n - 1]:
    if (i > 0 && nums[i] == nums[i - 1])
      continue;
    int target = -nums[i];
    int left = i + 1, right = nums.size() - 1;
    while (left < right)
    {            
      auto sum = nums[left] + nums[right];
      if (sum < target)
        ++left;
      else if (sum > target)
        --right;
      else
      {
        res.push_back({nums[i], nums[left], nums[right]});
        ++left;
        while (left < right && nums[left] == nums[left - 1])
          ++left;
        --right;
      }
    }
  }
  return res;
}
	\end{lstlisting}
	\subsection{\href{https://leetcode.com/problems/4sum/}{4sum}}
	\label{subsec:4sum}
	Given an array $nums$ of $n$ integers, return an array of all the \textbf{unique} quadruplets $[nums[a], nums[b], nums[c], nums[d]]$ such that $a < b < c < d$ and $nums[a] + nums[b] + nums[c] + nums[d] = target$.
	\par The base case for this solution is 2sum. For more information refer to \ref{subsec:twosumii}. It's a good idea to look at 3sum in \ref{subsec:3sum}
	\par We can solve it similar to 3sum (for more information refer to \ref{subsec:3sum}). We suppose the array is sorted. We use mathematical induction, so we know how to solve it for less than $n$ sorted numbers. Now we consider $n$ sorted numbers. We choose the first two numbers $nums[0]$ and $nums[1]$. We choose subproblem $nums[j..n - 1]$ such that $nums[m] = nums[0] \lor nums[m] = nums[1]$ for $2 \le m \le j - 1$. As explained in section \ref{subsec:3sum}, this is required to avoid duplication. We use mathematical induction to find quadruplets in $nums[j..n - 1]$. Then for finding quadruplets that contain $nums[0]$ and $nums[1]$, we use 2sum (refer to section \ref{subsec:twosumii}) algorithm on $nums[2..n-1]$ (not $nums[j..n - 1]$. For example $[0, 0, 0, 0]$ is a valid quadruplet if $target=0$).
	\begin{lstlisting}
vector<vector<int>> fourSum(vector<int>& nums, int target) {
  vector<vector<int>> res;
  const auto size = nums.size();
  sort(nums.begin(), nums.end());
  for (int i = 0; (i + 3) < size; ++i)
  {
    if (i > 0 && nums[i] == nums[i - 1])
      continue;
    for (int j = i + 1; (j + 2) < size; ++j)
    {
      if (j > i + 1 && nums[j] == nums[j - 1])
        continue;
      int t = target - nums[i] - nums[j];
      int left = j + 1;
      int right = size - 1;
      while (left < right)
      {
        int sum = nums[left] + nums[right];
        if (sum < t)
          ++left;
        else if (sum > t)
          --right;
        else
        {
          res.push_back({nums[i], nums[j], nums[left], nums[right]});
          ++left;
          while (nums[left] == nums[left - 1] && left < right)
            ++left;
          --right;
        }
      }
    }
  }
  return res;
}
	\end{lstlisting}
	To solve $ksum$ problem, we need $k - 2$ for loops to find $[nums[0], nums[1], \dots, nums[k - 3]]$ and we use 2sum algorithm to find $nums[k - 2]$ and $nums[k - 1]$. We can use a recursive function to solve the problem dynamically during the runtime.
	\begin{lstlisting}
vector<vector<int>> twosum(vector<int>& nums, int left, int target)
{
  int right = nums.size() -1;
  vector<vector<int>> res;
  while (left < right)
  {            
    auto sum = nums[left] + nums[right];
    if (sum < target)
      ++left;
    else if (sum > target)
      --right;
    else
    {
      res.push_back({nums[left], nums[right]});
      ++left;
      while (nums[left] == nums[left - 1] && left < right)
        ++left;
      --right;
    }
  }
  return res;
}
vector<vector<int>> ksum(vector<int>& nums, int start, int k, int target)
{
  vector<vector<int>> res;
  if (start == nums.size())
    return res;
  int average = target / k;
  //nums[start] * k > target
  if (nums[start] > average)
    return res;
  //nums.back() * k < target
  if (nums.back() < average)
    return res;
  if (k == 2)
    return twosum(nums, start, target);
  
  for (int i = start; i < nums.size(); ++i)
  {
    if (i > start && nums[i] == nums[i - 1])
      continue;
    auto partial = ksum(nums, i + 1, k - 1, target - nums[i]);
    for (auto& val : partial)
    {
      val.insert(val.begin(), nums[i]);
      res.push_back(val);
    }
  }
  return res;
}

vector<vector<int>> fourSum(vector<int>& nums, int target) {
  sort(nums.begin(), nums.end());
  return ksum(nums, 0, 4, target);
}
	\end{lstlisting}
	\subsection{\href{https://leetcode.com/problems/generate-parentheses/}{Generate Parentheses}}
	 Given $n$ pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
	 \par We use mathematical induction. Let's say $S_n$ is the set of all valid $n$ pairs. We assume we know how to generate $S_k$ for $k < n$. It's obvious that $S_1 = \{"()"\}$ and $S_0 = \{""\}$. Now we consider $S_n$. let's assume $p \in S_i$ and $q \in S_{n - 1 - i}$ for $0 \le i \le n - 1$. It's obvious that "(p)q" is a a valid parentheses with $n$ pairs ($i + n - 1 - i + 1 = n$). We define
	 \begin{equation*}
	 	(S_i) = \{(p) : p \in S_i\}
	 \end{equation*}
 	 Also we define \href{https://en.wikipedia.org/wiki/Cartesian_product}{Cartesian product} as follow ($pq$ means the concatenation of strings $p$ and $q$):
 	 \begin{equation*}
 	 	S_i \times S_j = \{pq : p \in S_i \land q \in S_j\}
 	 \end{equation*}
  	 So we can use the induction to generate $S_n$ as follow:
	 \begin{equation*}
	 	S_n = \bigcup_{i = 0}^{n - 1}{(S_i) \times S_{n - 1 - i}}
	 \end{equation*}
 	\begin{lstlisting}
vector<string> generateParenthesis(int n) {
  vector<string> res;
  if (n == 0)
    return {""};
  for (int i = 0; i < n; ++i)
  {
    auto set_left = generateParenthesis(i);
    auto set_right = generateParenthesis(n - i - 1);
    for (const auto& p : set_left)
    {
      string left_str = "(" + p + ")";
      for (const auto& q : set_right)
        res.push_back(left_str + q);
    }
  }
  return res;
}
 	\end{lstlisting}
	\subsection{\href{https://leetcode.com/problems/divide-two-integers/}{Divide Two Integers}}
	Divide two integers \textbf{without} using multiplication, division, and mod operator. We can only use \textbf{32-bit signed integers}.
	\par We know that the range of a 32-bit signed integer is $[-2^{31}, 2^{31} - 1]$. We should convert negative numbers to positive ones. The tricky part is how to handle $-2^{31}$. Because we cannot fit it inside a positive 32-bit integer and we are not allowed to use $unsigned$ variables.
	\subsubsection{Method 1}
	We use mathematical induction. Suppose $a = bq + r$. We define $div(a, b) = q$ and $mod(a, b) = r$. Suppose we know how to calculate $div$ and $mod$ for less than $a$. Now we want to calculate for $a$:
	\begin{equation*}
		\begin{split}
		div(a, b) &= \begin{cases}
			2 \times div(k, b) + div(2 \times mod(k, b), b) & a = 2k \\
			2 \times div(k, b) + div(2 \times mod(k, b) + 1 , b) & a = 2k + 1 \\
			0 & a < b \\
			1 & a = b \\
			a & b = 1 \\
			base_{div}(a, b) & k \le b
		\end{cases} \\
		mod(a, b) &= \begin{cases}
			mod(2 \times mod(k, b), b) & a = 2k \\
			mod(2 \times mod(k, b) + 1, b) & a = 2k + 1 \\
			a & a < b \\
			0 & a = b \lor b = 1 \\
			base_{mod}(a, b) & k \le b	
		\end{cases}	
		\end{split}	
	\end{equation*}
	For calculating $base$ we use a straightforward approach. Since we cannot use multiplication and division, we can use $2 \times a = a + a$ and we use shift operator to do division by 2 ($a >> 1$).
	\par Let's consider $a=-2^{31}$. Let's assume $q = div(2^{31}, |b|)$ and $r = mod(2^{31}, |b|)$:
	\begin{equation*}
		|div(-2^{31}, |b|)| = \begin{cases}
			q & r + 1 < |b| \\
			q + 1 & r + 1 \ge |b|
		\end{cases}
	\end{equation*}
	\subsubsection{Method2}
	This is easier to implement. We assume $a = bq + r$. We define $div(a, b) = q$. Like previous method, suppose we know how to calculate $div$ for less than $a$. Now we want to calculate for $a$. Suppose $b \times 2^k \le a < b \times 2^{k + 1}$. So we can say $a = b \times 2^k + r$. If $r < b$ we find the answer; otherwise we use the induction to find $r = bq^{\prime} + r^{\prime}$. So the answer is:
	\begin{equation*}
		\begin{split}
			a &= b \times 2^k + r \\
			  &= b \times 2^k + bq^{\prime} + r^{\prime} \\
			  &= b \times (2^k + q^\prime) + r^{\prime}
		\end{split}
	\end{equation*}
	We can summarize it as:
	\begin{equation*}
		div(a, b) = \begin{cases}
			2^k + div(a - b \times 2^k, b) & a \ge b \\
			0 & a < b
		\end{cases}
	\end{equation*}
	\par Let's consider $a=-2^{31}$. We cannot store it as positive in a 32-bit signed integer. Let's assume $a = bq + r$:
	\begin{equation*}
		\begin{split}
			&b(q - 1) + r \\
			&= bq + r - b \\
			&= a - b \\
			&\implies a - b = b(q - 1) + r
		\end{split}
	\end{equation*}
	So $div(|2^{31}|, |b|) = div(|2^{31}| - |b|, |b|) + 1$:
	\begin{lstlisting}
int div(int a, int b)
{
  if (a < b)
    return 0;        
  const int half_of_a = a >> 1;
  int q = 1, bq = b;
  for (; bq <= half_of_a; bq <<= 1, q <<= 1);
  return q + div(a - bq, b);
}

int divide(int a, int b) {
  static const int min_int = numeric_limits<int>::min();
  static const int max_int = numeric_limits<int>::max();
  int sign = 1;
  int res = 0;
  
  if (b == min_int)
    return a == min_int ? 1 : 0;
  if (b == 1)
    return a;
  if (b == -1)
    return a == min_int ? max_int : -a;
  
  if (b < 0)
    sign = -sign, b = -b;
  if (a == min_int)
    a += b, res = 1;
  if (a < 0)
    sign = -sign, a = -a;
  
  res += div(a, b);

  return res * sign;
}
	\end{lstlisting}
	\subsection{\href{https://leetcode.com/problems/next-permutation/}{Next Permutation}}
	Implement std::next\_permutation for $nums[0..n-1]$! For example if $nums = [1, 3, 2]$, the answer is $[2, 1,3]$
	\par Suppose $p$ and $q$ are two permutations of $nums[0..n - 1]$. If $p < q$, then we have a $0 \le i < n$ such that $p[k] = q[k]$ for $0 \le k < i$ and $p[i] < q[i]$. For solving this question we should find the smallest $q$ that is greater than $p$.
	\par Assume $i$ is the maximum index such that $nums[i] < nums[i + 1]$ for $0 \le i \le n - 2$. If such $i$ does not exist it means we have the last permutation. So we should return the first one. Since $i$ is the maximum index, it implies $nums[k] \ge nums[k + 1]$ for all $i + 1 \le k \le n - 2$. In other words, $nums[i + 1..n - 1]$ is in non-ascending order.
	\par Let's assume $j \ge i + 1$ is the maximum index such that $nums[i] < nums[j]$. Since $nums[i + 1..n - 1]$ is in non-ascending order, that means $nums[j]$ is the smallest element that is bigger than $nums[i]$ in that range. We should swap $nums[i]$ and $nums[j]$ and reverse $nums[i + 1..n - 1]$ to make it in non-descending order. This is the smallest permutation greater than $nums$.
	\par To summarize we break $nums[0..n - 1]$ into $A = nums[0..i]$ and $B = nums[i + 1..n - 1]$. The former is in non-descending and the latter in non-ascending order. We define $B^{\prime} = \{nums[j] \in B : nums[j] > nums[i]\}$. We find the smallest element in $B^{\prime}$ and swap it with $nums[i]$. Then we should sort $B$ in non-descending order.
	\par The implementation is based on \href{https://en.cppreference.com/w/cpp/algorithm/next_permutation}{possible implementation} of next\_permutation. To understand how reverse\_iterator::base ($i.base()$) works, refer to \ref{appendix:reverse_iterator}.
	\begin{lstlisting}
void nextPermutation(vector<int>& nums) {
  auto i = is_sorted_until(nums.rbegin(), nums.rend());
  if (i != nums.rend())
  {
    auto j = upper_bound(nums.rbegin(), i, *i);
    iter_swap(i, j);
  }
  //https://en.cppreference.com/w/cpp/iterator/reverse_iterator/base
  reverse(i.base(), nums.end());
}
	\end{lstlisting}
	\chapter{HackerRank}
	\section{\href{https://www.hackerrank.com/challenges/new-year-chaos/problem}{New Year Chaos}}
	 We define $index_i$ as the current index for person $i$. For example if we have $1, 2, 3, 4$ and $4$ bribes $3$, the queue looks like $1, 2, 4, 3$. So $index_4 = 3$. Since no body can bribe more than 2 times, $index_i \ge i - 2$ for $1 \le i \le n$. Consider person $n$. No body can bribe that person. So $n - 2 \le index_n \le n$. After we retruned that person to his actual place we can consider $n - 1$. So we have $n - 3 \le index_{n - 1} \le n - 1$ (note that at this moment $index_n = n$).
	 \begin{lstlisting}
void minimumBribes(vector<int> q) {

    const auto& n = q.size();
    int res = 0;
    for (int num = n; num > 0; --num)
    {
        for (int i = max(0, num - 3); i < num - 1; ++i)
        {
            if (q[i] == num)
            {
                ++res;
                swap(q[i], q[i + 1]);
            }
        }
        if (q[num - 1] != num)
        {
            cout << "Too chaotic" << endl;
            return;
        }
    }
    cout << res << endl;
}
	 \end{lstlisting}
	 
	 \section{\href{https://www.hackerrank.com/challenges/minimum-swaps-2/problem}{Minimum Swaps 2}}
 	Note that this solution is based on \href{https://en.wikipedia.org/wiki/Selection_sort}{Selection Sort} in which the number of swaps are minimum. According to Wikipedia: "One thing which distinguishes selection sort from other sorting algorithms is that it makes the minimum possible number of swaps, n − 1 in the worst case.". Altourh Selection sort has minimum number of swaps among all sorts agorithms, it has $O(n^2)$ comparisons. Since the final result is $\{1, 2, \dots, n\}$, it's like we have the set in sorted order so we can bypass comparisons and use Selection Sort advantage which is the minimum number of swaps.
	 \par We define $index_i$ as the current index of number $i$. Suppose we have $n$ numbers, so $1 \le index_i \le n$. The goal is to have $index_i = i$. Without losing generality suppose $i < j \land index_i = j$. There are two cases to consider:
	 \begin{enumerate}
	 	\item If $index_j = i$, then by swapping $arr_i$ and $arr_j$, we put both $i$ and $j$ in their corresponding positions.
	 	\item If $index_j = k \land k \ne i \land k \ne j$. In this case by swapping $arr_i$ and $arr_j$ we only put $i$ in its corresponding position. So we need to do an extra swap to put $j$ in its correct position.
	 \end{enumerate}
 	We can start from $i = 1$ to $i = n$ and make sure $i$ is in correct position; otherwise we perform a swap. In each iteration we fix the position of one or two numbers. A good example is \{4, 3, 2, 1\}.
 	
 	\begin{lstlisting}
    int minimumSwaps(vector<int> arr) {

    const auto& n = arr.size();
    vector<int> index(n + 1);

    for (int i = 0; i < n; ++i)
        index[arr[i]] = i;
    int cnt = 0;
    for (int num = 1; num <= n; ++num)
    {
        if (index[num] != num - 1)
        {
            ++cnt;
            index[arr[num - 1]] = index[num];
            swap(arr[index[num]], arr[num - 1]);
            index[num] = num - 1;
        }
    }
    return cnt;
}
 	\end{lstlisting}
 	\section{\href{https://www.hackerrank.com/challenges/count-triplets-1/problem}{Count Triplets}}	
 	We use dynamic programming to solve it. For mathematical induciton we define $cnt[num][n]$ like this:
 	
 	\begin{equation*}
 		\begin{split}
 		cnt[a_{i_1}][0] &= |\{a_{i_0} \in arr \text{ }| \text{ } a_{i_1} = a_{i_0} \times r \text{ }\land \text{ } i_1 < i_2\}| \\
 		cnt[a_{i_2}][1] &= |\{(a_{i_0}, a_{i_1}) \in arr \times arr \text{ }| \text{ } a_{i_k} = a_{i_{k - 1}} \times r \text{ }\land \text{ } i_{k - 1} < i_k  \text{ for }1 \le k \le 2\}|
 		\end{split}
 	\end{equation*}
 	So the final answer is:
 	\begin{equation*}
 	\sum_{n \in arr}{cnt[n][1]}
 	\end{equation*}
 	Then for each number $n$ we have
 	
 	\begin{equation*}
 	\begin{split}
 	cnt[n \times r][0] &= cnt[n \times r][0] + 1 \\
 	cnt[n \times r][1] &= cnt[n \times r][1] + cnt[n][0]
 	\end{split}
 	\end{equation*}
 	Since $r = 1$, the order of assignments are very important.
 	
 	\begin{lstlisting}
        long countTriplets(vector<long> arr, long r) {
            const auto n = arr.size();
            unordered_map<long, array<long, 2>> cnt;
            //cnt[a[j]][0] = |{a[i]}| in which i < j and 
            //               a[j] = a[i] * r
            //cnt[a[k]][1] = |{a[i], a[j]}| in which 
            //               i < j < k and 
            //a[k] = a[j] * r and a[j] = a[i] * r
            
            long res = 0;
            for (const auto& num : arr)
            {
                res += cnt[num][1];
                const auto next = num * r;
                cnt[next][1] += cnt[num][0];
                ++cnt[next][0];                       
            }
            return res;
        }
 	
 	\end{lstlisting}
	\section{\href{https://www.hackerrank.com/challenges/fraudulent-activity-notifications/problem}{Fraudulent Activity Notifications}}
	Basically we want a $O(nlogn)$ algorithm to find median of a sequuence, when we removed the first element and add another one. So we need two binary search trees. In the first one the maximum element is the median itself and in the secon one the minimum element is the second median in case of $d = 2k$ or a value greater than median when $d = 2k + 1$. So if $d = 2k$ both of these binary search trees always have $k$ element. When $d = 2k + 1$, the first one always has $k + 1$ elements and the second one has $k$ elements. Let's call them $lessEqual$ and $greaterEqual$.
	\par If both removing element and new element belong to the same tree, nothing extra is required. So we only need to remove one element and add the new one. If the removing element is from $lessEqual$, we must remove the minimum element from $greaterEqual$ and add it to $lessEqual$. If the removing element is from $greaterEqual$, we must remove the maximum element from $lessEqaul$ and add it to $greaterEqual$. By doing that the maximum element is $lessEqual$ is median. In case of $d = 2k$, the minimum element in $greaterEqual$ is the second median. The running time of this algorithm is $O(nlogn)$.
	\begin{lstlisting}
int activityNotifications(vector<int> expenditure, int d)
{
    multiset<int, greater<int>> lessEqual;
    multiset<int> greaterEqual;

    vector<int> init(d);
    copy(expenditure.begin(), expenditure.begin() + d,
         init.begin());
    sort(init.begin(), init.end());

    const bool isEven = (d & 1) == 0;

    int medianIndex = (d - 1) / 2;
    int i;
    for (i = 0; i <= medianIndex; ++i)
        lessEqual.insert(init[i]);
    for (; i < d; ++i)
        greaterEqual.insert(init[i]);
    
    int res = 0;
    for (int i = d; i < expenditure.size(); ++i)
    {
        const int median1 = *lessEqual.begin();
        if (isEven)
        {
            const int median2 = *greaterEqual.begin();
            if (expenditure[i] >= (median1 + median2))
                ++res;
        }
        else 
        {
            if (expenditure[i] >= 2 * median1)
                ++res;
        }

        const auto removed = expenditure[i - d];

        if (removed <= median1 && 
            expenditure[i] <= median1)            
        {
            lessEqual.erase(lessEqual.find(removed));
            lessEqual.insert(expenditure[i]);
        }
        else if (removed > median1 && 
                 expenditure[i] > median1)
        {
          greaterEqual.erase(greaterEqual.find(removed));
          greaterEqual.insert(expenditure[i]);
        }
        else if ( removed <= median1)
        {
            //For handling d=1, it should first:
            greaterEqual.insert(expenditure[i]);
            lessEqual.erase(lessEqual.find(removed));
            lessEqual.insert(*greaterEqual.begin());
            greaterEqual.erase(greaterEqual.begin());
        }
        else
        {
          //For handling d=1, it should be first:
          lessEqual.insert(expenditure[i]);
          greaterEqual.erase(greaterEqual.find(removed));
          greaterEqual.insert(*lessEqual.begin());
          lessEqual.erase(lessEqual.begin());
        }
    }
    return res;
}
	
	\end{lstlisting}
	\section{\href{https://www.hackerrank.com/challenges/ctci-merge-sort/problem}{Merge Sort: Counting Inversions}}
	\href{https://www.hackerrank.com/challenges/ctci-merge-sort/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=sorting}{Problem Statement}
	\par We can solve it using merge sort. Suppose we have $arr[left..right]$. We break it into two subproblem $arr[left..mid]$ and $arr[mid + 1..right]$. Both of them are sorted. According to merge sort algorithm $left \le i \le mid$ and $mid + 1 \le j \le right$. In other words we already put $arr[left..i - 1]$ and $arr[mid + 1..j - 1]$ into their correct positions. So when $arr[j] < arr[i]$, it means $arr[j] < arr[i] \le arr[x]$ in which $i + 1 \le x \le mid$. So we need to have $mid - i + 1$ swaps.
	\begin{lstlisting}
long mergeSort(vector<int>& arr, int leftIndex, 
               int rightIndex)
{
    if (leftIndex == rightIndex)
        return 0;
        
    long res = 0;
    int midIndex = (leftIndex + rightIndex) / 2;
    res = mergeSort(arr, leftIndex, midIndex);
    res += mergeSort(arr, midIndex + 1, rightIndex);

    vector<int> sorted(rightIndex - leftIndex + 1);
    int i, j, k;
    for (i = leftIndex, j = midIndex + 1, k = 0; 
         i <= midIndex && j <= rightIndex;)
    {
        if (arr[i] <= arr[j])
            sorted[k++] = arr[i++];
        else  
        {            
            res += midIndex - i + 1;
            sorted[k++] = arr[j++];
        }
    }
    if (i <= midIndex)
        copy(arr.begin() + i, 
             arr.begin() + midIndex + 1, 
             sorted.begin() + k);
    else  
        copy(arr.begin() + j , 
             arr.begin() + rightIndex + 1,
             sorted.begin() + k);
    copy(sorted.begin(), sorted.end(), 
         arr.begin() + leftIndex);
    return res;
}
// Complete the countInversions function below.
long countInversions(vector<int> arr) {
    return mergeSort(arr, 0, arr.size() - 1);
}
	\end{lstlisting}
	\chapter{TopCoder}
	\section{SRM 428}
	\subsection{\href{https://community.topcoder.com/stat?c=problem_statement&pm=10182&rd=13519}{ThePalindrome}}
	\label{subsec:the_palindrome}
	For another variation refer to \ref{subsec:longest_palindromic_substr}.
	We want to add the minimum number of characters to the end of string to make it a palindrome. The straightforward approach is to try add the first $i$ characters in reverse for all $0 \le i \le n - 1$ in which $n$ is the length of string. So we start from $i = 0$ and check whether the string is palindrome. If it's not we check for $i = 1$ and so on. The running time of this algorithm is $O(n^2)$.
	
	\begin{lstlisting}
bool isPalindrome(const string& str)
{
  int left = 0, right = str.length() - 1;
  for (; left < right && str[left] == str[right]; 
         ++left, --right);
  return left >= right;
}

int find(string s)
{
  for (int i = 0; i < s.length(); ++i)
  {
    string tmp = s + string(s.rend() - i, s.rend());
    if (isPalindrome(tmp))
      return tmp.length();
  }
  throw 1;
}
	\end{lstlisting}
	Since $n \le 50$, this algorithm is fast. We can make it $O(n\log_2{n})$ if we use binary search tree to find the minimum $i$.
	\par There is another approach. Let's assume we have string $S = s_1 s_2 \dots s_n$. We define $S^\prime = s_n \dots s_2 s_1$. Suppose we can write string $S$ as $QP$. In other words, $S$ is the concatenation of two strings $Q$ and $P$. We assume $P$ is palindrome but $Q$ is not. We can make $S$ palindrome if we convert $QP$ to $QPQ^\prime$ we call this new String $Z$. $Z$ is palindrome because if we reverse it we have:
	\begin{equation*}
		\begin{matrix}
			Z: & QPQ^\prime \\
			Z^\prime : & QP^\prime Q^\prime
		\end{matrix}
	\end{equation*}	
	Since we want the length of $Q$	be minimum, we must find the maximal $P$:
	\begin{lstlisting}
bool isPalindrome(const string& str, int start)
{
  int left = start, right = str.length() - 1;
  for (; left < right && str[left] == str[right]; 
         ++left, --right);
  return left >= right;
}

int find(string s)
{
  for (int i = 0; i  < s.length(); ++i)
  {
    if (isPalindrome(s, i))
      return s.length() + i;
  }
  throw 1;
}
	
	\end{lstlisting}
	As the previous implementation the running time is $O(n^2)$ but it's easy to convert it to $O(n\log_2n)$ using binary search.
	\par This implementation has a unique feature. We can convert it to an $O(n)$ algorithm using \href{https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm}{KMP algorithm}. Suppose $S=QP$ where $P$ is a palindrome. We want to find palidnrome postfix $P$ which its length is maximum among all palindrome post-fixes. We need to run KMP pre-compute calculation on $S^\prime = P^\prime Q^\prime$. Then we run KMP algorithm as if we want to find whether $S^\prime$ is a substring of $S$. Suppose we use $i$ as an index for $S$ and $j$ as an index for $S^\prime$. The algorithm start with $i = 0$ and ends when $i = len(S)$ in which $S^\prime[0..j - 1]$ is $P^\prime$ or $P$ (since it's palindrome).
	
	\begin{lstlisting}
vector<int> calculateNext(const string& B)
{
  vector<int> next(B.length());
  next[0] = -2;
  next[1] = -1;
  int i, j;
  for (i = 2; i < B.length(); ++i)
  {
    j = next[i - 1] + 1;
    for (; j >= 0 && B[j] != B[i - 1]; j = next[j] + 1);
    next[i] = j;
  }
  return next;
}

int find(string A)
{
  const string B = string(A.rbegin(), A.rend());
  const auto next = calculateNext(B);
  int i, j;
  for (i = 0, j = 0; i < A.length() && j < B.length();)
  {
    if (A[i] == B[j])
      ++i, ++j;
    else if ((j = next[j] + 1) < 0)
    {
      //Since B.front() == A.back(), it's impoosible
      //i == A.length() here:
      ++i, j = 0;
      j = 0;
    }
  }
  int palindromeLen = j;
  return A.length() + A.length() - palindromeLen; 
}	
	\end{lstlisting}
	\appendix
	\chapter{C++ refresher}
	\section{Inserting into a container}
	The following code uses most insert operations:
	\begin{lstlisting}
#include <iostream>
#include <vector>
#include <deque>
#include <iterator>
#include <algorithm>

template<typename Container>
void print(const Container& c)
{
  static int id = 1;
  std::cout << id++ << ": ";
  std::for_each(c.begin(), c.end(), [](const auto& val) {
                std::cout << val << ' ';
                });
  std::cout << std::endl;
}

int main()
{
  std::vector<int> base{0, 1, 2, 3, 4};
  auto v(base);
  std::vector<int> v2{100, 200, 300};

  auto i = std::next(v.begin()); // v.begin() + 1
  i = v.insert(i, v2[0]);
  i = v.insert(i, v2[1]);
  i = v.insert(i, v2[2]);
  print(v); // 1: 0 300 200 100 1 2 3 4
  // Note that after
  // v.insert(i, v[0]);
  // i becomes invalid. So this is undefined behavior:
  // v.insert(i, v[1]);
  v = base;
  i = std::next(v.begin()); // v.begin() + 1
  i = v.insert(i, v2.begin(), v2.end());
  print(v); // 2: 0 100 200 300 1 2 3 4
        
  v = base;
  std::copy(v2.begin(), v2.end(),
            std::inserter(v, std::next(v.begin(), 1)));
  print(v); // 3: 0 100 200 300 1 2 3 4
  
  v = base;
  std::copy(v2.begin(), v2.end(), std::back_inserter(v));
  print(v); // 4: 0 1 2 3 4 100 200 300
  
  //std::vector doesn't have push_front:
  std::deque<int> d(base.begin(), base.end());
  std::copy(v2.begin(), v2.end(), std::front_inserter(d));
  print(d); // 1: 300 200 100 0 1 2 3 4
}
	\end{lstlisting}
	\section{\href{https://en.cppreference.com/w/cpp/iterator/reverse_iterator}{std::reverse\_iterator}}
	\label{appendix:reverse_iterator}
	 To understand how \href{https://en.cppreference.com/w/cpp/iterator/reverse_iterator/base}{reverse\_iterator::base} works, see the following snippet. For more information refer to \href{https://en.cppreference.com/w/cpp/iterator/reverse_iterator}{std::reverse\_iterator}.
	\begin{lstlisting}
int main()
{
  using iter = std::vector<int>::iterator;
  using r_iter = std::vector<int>::reverse_iterator;

  std::vector<int> v {0, 1, 2, 3, 4};
  r_iter res = std::find(v.rbegin(), v.rend(), 2);
  iter base = res.base();
  assert(*res == 2 && *base == 3);
}
	\end{lstlisting}
\end{document}
