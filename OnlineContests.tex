\documentclass{book} 

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{float}
\usepackage{hyperref}
\usepackage{placeins}
\usepackage{amssymb}
\usepackage{listings}

\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{snakes}
\usetikzlibrary{decorations.pathmorphing}

\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}

\title{Online Contests Solutions}
\author{Saman Saadi}
\date{} 

\begin{document}
	\frontmatter
	\maketitle
%	\newpage
	\tableofcontents
	\mainmatter
	\chapter{HackerRank}
	\section{New Year Chaos}
	 You can find the question in this \href{https://www.hackerrank.com/challenges/new-year-chaos/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=arrays}{link}.
	 \par We define $index_i$ as the current index for person $i$. For example if we have $1, 2, 3, 4$ and $4$ bribes $3$, the queue looks like $1, 2, 4, 3$. So $index_4 = 3$. Since no body can bribe more than 2 times, $index_i \ge i - 2$ for $1 \le i \le n$. Consider person $n$. No body can bribe that person. So $n - 2 \le index_n \le n$. After we retruned that person to his actual place we can consider $n - 1$. So we have $n - 3 \le index_{n - 1} \le n - 1$ (note that at this moment $index_n = n$).
	 \begin{lstlisting}
void minimumBribes(vector<int> q) {

    const auto& n = q.size();
    int res = 0;
    for (int num = n; num > 0; --num)
    {
        for (int i = max(0, num - 3); i < num - 1; ++i)
        {
            if (q[i] == num)
            {
                ++res;
                swap(q[i], q[i + 1]);
            }
        }
        if (q[num - 1] != num)
        {
            cout << "Too chaotic" << endl;
            return;
        }
    }
    cout << res << endl;
}
	 \end{lstlisting}
	 
	 \section{Minimum Swaps 2}
	 See the problem statement in this \href{https://www.hackerrank.com/challenges/minimum-swaps-2/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=arrays}{link}.
 	\par Note that this solution is based on \href{https://en.wikipedia.org/wiki/Selection_sort}{Selection Sort} in which the number of swaps are minimum. According to Wikipedia: "One thing which distinguishes selection sort from other sorting algorithms is that it makes the minimum possible number of swaps, n âˆ’ 1 in the worst case.". Altourh Selection sort has minimum number of swaps among all sorts agorithms, it has $O(n^2)$ comparisons. Since the final result is $\{1, 2, \dots, n\}$, it's like we have the set in sorted order so we can bypass comparisons and use Selection Sort advantage which is the minimum number of swaps.
	 \par We define $index_i$ as the current index of number $i$. Suppose we have $n$ numbers, so $1 \le index_i \le n$. The goal is to have $index_i = i$. Without losing generality suppose $i < j \land index_i = j$. There are two cases to consider:
	 \begin{enumerate}
	 	\item If $index_j = i$, then by swapping $arr_i$ and $arr_j$, we put both $i$ and $j$ in their corresponding positions.
	 	\item If $index_j = k \land k \ne i \land k \ne j$. In this case by swapping $arr_i$ and $arr_j$ we only put $i$ in its corresponding position. So we need to do an extra swap to put $j$ in its correct position.
	 \end{enumerate}
 	We can start from $i = 1$ to $i = n$ and make sure $i$ is in correct position; otherwise we perform a swap. In each iteration we fix the position of one or two numbers. A good example is \{4, 3, 2, 1\}.
 	
 	\begin{lstlisting}
    int minimumSwaps(vector<int> arr) {

    const auto& n = arr.size();
    vector<int> index(n + 1);

    for (int i = 0; i < n; ++i)
        index[arr[i]] = i;
    int cnt = 0;
    for (int num = 1; num <= n; ++num)
    {
        if (index[num] != num - 1)
        {
            ++cnt;
            index[arr[num - 1]] = index[num];
            swap(arr[index[num]], arr[num - 1]);
            index[num] = num - 1;
        }
    }
    return cnt;
}
 	\end{lstlisting}
 	\section{Count Triplets}
 	\href{https://www.hackerrank.com/challenges/count-triplets-1/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=dictionaries-hashmaps}{Problem statement}.
 		
 	\par We use dynamic programming to solve it. For mathematical induciton we define $cnt[num][n]$ like this:
 	
 	\begin{equation*}
 		\begin{split}
 		cnt[a_{i_1}][0] &= |\{a_{i_0} \in arr \text{ }| \text{ } a_{i_1} = a_{i_0} \times r \land i_1 < i_2\}| \\
 		cnt[a_{i_2}][1] &= |\{(a_{i_0}, a_{i_1}) \in arr \times arr \text{ }| \text{ } a_{i_k} = a_{i_{k - 1}} \times r \land i_{k - 1} < i_k  \text{ for }1 \le k \le 2\}|
 		\end{split}
 	\end{equation*}
 	So the final answer is:
 	\begin{equation*}
 	\sum_{n \in arr}{cnt[n][1]}
 	\end{equation*}
 	Then for each number $n$ we have
 	
 	\begin{equation*}
 	\begin{split}
 	cnt[n \times r][0] &= cnt[n \times r][0] + 1 \\
 	cnt[n \times r][1] &= cnt[n \times r][1] + cnt[n][0]
 	\end{split}
 	\end{equation*}
 	Since $r = 1$, the order of assignments are very important.
 	
 	\begin{lstlisting}
        long countTriplets(vector<long> arr, long r) {
            const auto n = arr.size();
            unordered_map<long, array<long, 2>> cnt;
            //cnt[a[j]][0] = |{a[i]}| in which i < j and a[j] = a[i] * r
            //cnt[a[k]][1] = |{a[i], a[j]}| in which i < j < k and 
            //a[k] = a[j] * r and a[j] = a[i] * r
            
            long res = 0;
            for (const auto& num : arr)
            {
                res += cnt[num][1];
                const auto next = num * r;
                cnt[next][1] += cnt[num][0];
                ++cnt[next][0];                       
            }
            return res;
        }
 	
 	\end{lstlisting}
\end{document}
