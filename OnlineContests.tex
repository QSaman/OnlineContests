\documentclass{book} 

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{float}
\usepackage{hyperref}
\usepackage{placeins}
\usepackage{amssymb}
\usepackage{listings}

\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{snakes}
\usetikzlibrary{decorations.pathmorphing}

\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}

\title{Online Contests Solutions}
\author{Saman Saadi}
\date{} 

\begin{document}
	\frontmatter
	\maketitle
%	\newpage
	\tableofcontents
	\mainmatter
	\chapter{HackerRank}
	\section{New Year Chaos}
	 You can find the question in this \href{https://www.hackerrank.com/challenges/new-year-chaos/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=arrays}{link}.
	 \par We define $index_i$ as the current index for person $i$. For example if we have $1, 2, 3, 4$ and $4$ bribes $3$, the queue looks like $1, 2, 4, 3$. So $index_4 = 3$. Since no body can bribe more than 2 times, $index_i \ge i - 2$ for $1 \le i \le n$. Consider person $n$. No body can bribe that person. So $n - 2 \le index_n \le n$. After we retruned that person to his actual place we can consider $n - 1$. So we have $n - 3 \le index_{n - 1} \le n - 1$ (note that at this moment $index_n = n$).
	 \begin{lstlisting}
void minimumBribes(vector<int> q) {

    const auto& n = q.size();
    int res = 0;
    for (int num = n; num > 0; --num)
    {
        for (int i = max(0, num - 3); i < num - 1; ++i)
        {
            if (q[i] == num)
            {
                ++res;
                swap(q[i], q[i + 1]);
            }
        }
        if (q[num - 1] != num)
        {
            cout << "Too chaotic" << endl;
            return;
        }
    }
    cout << res << endl;
}
	 \end{lstlisting}
	 
	 \section{Minimum Swaps 2}
	 See the problem statement in this \href{https://www.hackerrank.com/challenges/minimum-swaps-2/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=arrays}{link}.
 	\par Note that this solution is based on \href{https://en.wikipedia.org/wiki/Selection_sort}{Selection Sort} in which the number of swaps are minimum. According to Wikipedia: "One thing which distinguishes selection sort from other sorting algorithms is that it makes the minimum possible number of swaps, n âˆ’ 1 in the worst case.". Altourh Selection sort has minimum number of swaps among all sorts agorithms, it has $O(n^2)$ comparisons. Since the final result is $\{1, 2, \dots, n\}$, it's like we have the set in sorted order so we can bypass comparisons and use Selection Sort advantage which is the minimum number of swaps.
	 \par We define $index_i$ as the current index of number $i$. Suppose we have $n$ numbers, so $1 \le index_i \le n$. The goal is to have $index_i = i$. Without losing generality suppose $i < j \land index_i = j$. There are two cases to consider:
	 \begin{enumerate}
	 	\item If $index_j = i$, then by swapping $arr_i$ and $arr_j$, we put both $i$ and $j$ in their corresponding positions.
	 	\item If $index_j = k \land k \ne i \land k \ne j$. In this case by swapping $arr_i$ and $arr_j$ we only put $i$ in its corresponding position. So we need to do an extra swap to put $j$ in its correct position.
	 \end{enumerate}
 	We can start from $i = 1$ to $i = n$ and make sure $i$ is in correct position; otherwise we perform a swap. In each iteration we fix the position of one or two numbers. A good example is \{4, 3, 2, 1\}.
 	
 	\begin{lstlisting}
    int minimumSwaps(vector<int> arr) {

    const auto& n = arr.size();
    vector<int> index(n + 1);

    for (int i = 0; i < n; ++i)
        index[arr[i]] = i;
    int cnt = 0;
    for (int num = 1; num <= n; ++num)
    {
        if (index[num] != num - 1)
        {
            ++cnt;
            index[arr[num - 1]] = index[num];
            swap(arr[index[num]], arr[num - 1]);
            index[num] = num - 1;
        }
    }
    return cnt;
}
 	\end{lstlisting}
 	\section{Count Triplets}
 	\href{https://www.hackerrank.com/challenges/count-triplets-1/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=dictionaries-hashmaps}{Problem statement}.
 		
 	\par We use dynamic programming to solve it. For mathematical induciton we define $cnt[num][n]$ like this:
 	
 	\begin{equation*}
 		\begin{split}
 		cnt[a_{i_1}][0] &= |\{a_{i_0} \in arr \text{ }| \text{ } a_{i_1} = a_{i_0} \times r \text{ }\land \text{ } i_1 < i_2\}| \\
 		cnt[a_{i_2}][1] &= |\{(a_{i_0}, a_{i_1}) \in arr \times arr \text{ }| \text{ } a_{i_k} = a_{i_{k - 1}} \times r \text{ }\land \text{ } i_{k - 1} < i_k  \text{ for }1 \le k \le 2\}|
 		\end{split}
 	\end{equation*}
 	So the final answer is:
 	\begin{equation*}
 	\sum_{n \in arr}{cnt[n][1]}
 	\end{equation*}
 	Then for each number $n$ we have
 	
 	\begin{equation*}
 	\begin{split}
 	cnt[n \times r][0] &= cnt[n \times r][0] + 1 \\
 	cnt[n \times r][1] &= cnt[n \times r][1] + cnt[n][0]
 	\end{split}
 	\end{equation*}
 	Since $r = 1$, the order of assignments are very important.
 	
 	\begin{lstlisting}
        long countTriplets(vector<long> arr, long r) {
            const auto n = arr.size();
            unordered_map<long, array<long, 2>> cnt;
            //cnt[a[j]][0] = |{a[i]}| in which i < j and a[j] = a[i] * r
            //cnt[a[k]][1] = |{a[i], a[j]}| in which i < j < k and 
            //a[k] = a[j] * r and a[j] = a[i] * r
            
            long res = 0;
            for (const auto& num : arr)
            {
                res += cnt[num][1];
                const auto next = num * r;
                cnt[next][1] += cnt[num][0];
                ++cnt[next][0];                       
            }
            return res;
        }
 	
 	\end{lstlisting}
	\section{Fraudulent Activity Notifications}
	\href{https://www.hackerrank.com/challenges/fraudulent-activity-notifications/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=sorting}{Problem Statement}
	\par Basically we want a $O(nlogn)$ algorithm to find median of a sequuence, when we removed the first element and add another one. So we need two binary search trees. In the first one the maximum element is the median itself and in the secon one the minimum element is the second median in case of $d = 2k$ or a value greater than median when $d = 2k + 1$. So if $d = 2k$ both of these binary search trees always have $k$ element. When $d = 2k + 1$, the first one always has $k + 1$ elements and the second one has $k$ elements. Let's call them $lessEqual$ and $greaterEqual$.
	\par If both removing element and new element belong to the same tree, nothing extra is required. So we only need to remove one element and add the new one. If the removing element is from $lessEqual$, we must remove the minimum element from $greaterEqual$ and add it to $lessEqual$. If the removing element is from $greaterEqual$, we must remove the maximum element from $lessEqaul$ and add it to $greaterEqual$. By doing that the maximum element is $lessEqual$ is median. In case of $d = 2k$, the minimum element in $greaterEqual$ is the second median. The running time of this algorithm is $O(nlogn)$.
	\begin{lstlisting}
int activityNotifications(vector<int> expenditure, int d) {
    multiset<int, greater<int>> lessEqual;
    multiset<int> greaterEqual;

    vector<int> init(d);
    copy(expenditure.begin(), expenditure.begin() + d, init.begin());
    sort(init.begin(), init.end());

    const bool isEven = (d & 1) == 0;

    int medianIndex = (d - 1) / 2;
    int i;
    for (i = 0; i <= medianIndex; ++i)
        lessEqual.insert(init[i]);
    for (; i < d; ++i)
        greaterEqual.insert(init[i]);
    
    int res = 0;
    for (int i = d; i < expenditure.size(); ++i)
    {
        const int median1 = *lessEqual.begin();
        if (isEven)
        {
            const int median2 = *greaterEqual.begin();
            if (expenditure[i] >= (median1 + median2))
                ++res;
        }
        else 
        {
            if (expenditure[i] >= 2 * median1)
                ++res;
        }

        const auto removed = expenditure[i - d];

        if (removed <= median1 && expenditure[i] <= median1)            
        {
            lessEqual.erase(lessEqual.find(removed));
            lessEqual.insert(expenditure[i]);
        }
        else if (removed > median1 && expenditure[i] > median1)
        {
            greaterEqual.erase(greaterEqual.find(removed));
            greaterEqual.insert(expenditure[i]);
        }
        else if ( removed <= median1)
        {
            //For handling d=1, it should first:
            greaterEqual.insert(expenditure[i]);
            lessEqual.erase(lessEqual.find(removed));
            lessEqual.insert(*greaterEqual.begin());
            greaterEqual.erase(greaterEqual.begin());
        }
        else
        {
            //For handling d=1, it should be first:
            lessEqual.insert(expenditure[i]);
            greaterEqual.erase(greaterEqual.find(removed));
            greaterEqual.insert(*lessEqual.begin());
            lessEqual.erase(lessEqual.begin());
        }
    }
    return res;
}
	
	\end{lstlisting}
	\section{Merge Sort: Counting Inversions}
	\href{https://www.hackerrank.com/challenges/ctci-merge-sort/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=sorting}{Problem Statement}
	\par We can solve it using merge sort. Suppose we have $arr[left..right]$. We break it into two subproblem $arr[left..mid]$ and $arr[mid + 1..right]$. Both of them are sorted. According to merge sort algorithm $left \le i \le mid$ and $mid + 1 \le j \le right$. In other words we already put $arr[left..i - 1]$ and $arr[mid + 1..j - 1]$ into their correct positions. So when $arr[j] < arr[i]$, it means $arr[j] < arr[i] \le arr[x]$ in which $i + 1 \le x \le mid$. So we need to have $mid - i + 1$ swaps.
	\begin{lstlisting}
long mergeSort(vector<int>& arr, int leftIndex, int rightIndex)
{
    if (leftIndex == rightIndex)
        return 0;
        
    long res = 0;
    int midIndex = (leftIndex + rightIndex) / 2;
    res = mergeSort(arr, leftIndex, midIndex);
    res += mergeSort(arr, midIndex + 1, rightIndex);

    vector<int> sorted(rightIndex - leftIndex + 1);
    int i, j, k;
    for (i = leftIndex, j = midIndex + 1, k = 0; 
         i <= midIndex && j <= rightIndex;)
    {
        if (arr[i] <= arr[j])
            sorted[k++] = arr[i++];
        else  
        {            
            res += midIndex - i + 1;
            sorted[k++] = arr[j++];
        }
    }
    if (i <= midIndex)
        copy(arr.begin() + i, arr.begin() + midIndex + 1, 
            sorted.begin() + k);
    else  
        copy(arr.begin() + j , arr.begin() + rightIndex + 1,
             sorted.begin() + k);
    copy(sorted.begin(), sorted.end(), arr.begin() + leftIndex);
    return res;
}
// Complete the countInversions function below.
long countInversions(vector<int> arr) {
    return mergeSort(arr, 0, arr.size() - 1);
}
	\end{lstlisting}
\end{document}
